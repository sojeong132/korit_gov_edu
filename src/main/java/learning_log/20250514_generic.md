# Generic 프로젝트 정리

## 🔥 해야 할 것 (해당 프로젝트 개요)

- 제네릭(Generic) 활용한 저장소 설계
- 다양한 하위 클래스(Student, HighStudent, AcademyStudent)를 유연하게 처리
- Stream과 와일드카드(`? extends`) 개념 활용

---

## 📌 개념 구조

| 구성 요소 | 설명 |
|:---|:---|
| `Student` | 기본 학생 클래스 |
| `HighStudent`, `AcademyStudent` | Student를 상속한 하위 클래스들 |
| `Repository<T>` | 제네릭 기반 저장소 클래스 |
| `Main` | 제네릭 와일드카드 활용 및 실행 메인 클래스 |

---

# 📌 내가 테스트하고 이해해본 과정 정리

## 고민
- 하위 클래스마다 Repository를 따로 생성하면 너무 비효율적이었다.
- 같은 기능인데 타입만 다른 객체를 처리하는데 반복되는 코드가 많았다.

## 도입
- `Repository<T>` 형태로 제네릭을 사용해서 타입을 유연하게 받도록 설계했다.
- `<S extends T>`를 사용해 저장하는 객체가 T의 하위 타입이면 무엇이든 받아들이고, 저장 후 그 타입 그대로 반환하도록 했다.

## 고민 (Stream과 와일드카드)
- 전통적인 for문은 길고 복잡했다.
- Stream을 사용하면 가독성이 올라가고 선언형 프로그래밍이 가능해졌다.
- 하지만 `? extends T`를 사용하면 읽기 전용(Write 제한)이 된다는 점을 주의해야 했다.

## 깨달은 점
- 제네릭은 코드 중복 제거 + 타입 안전성 확보를 동시에 가능하게 한다.
- 와일드카드는 자료형 추론을 제한하지만, 여러 하위 타입을 처리할 때 필수적인 도구다.
- Stream은 선언형 프로그래밍 방식으로 컬렉션을 쉽게 조작할 수 있게 해주며, 필터링과 매핑 같은 작업이 깔끔해진다.

---

# 🚨 주의사항 (개선 또는 인지 포인트)

| 항목 | 주의/개선 사항 |
|:---|:---|
| 와일드카드 `? extends` 제한 | 읽기만 가능, 저장(save)은 불가 |
| 필드 명명 규칙 | HighSchool → Java 표준은 소문자 시작(highSchool) 권장 |
| 객체 초기화 시 이름 설정 없음 | setName()을 통해 초기 이름 부여하는 생성자 추가 추천 |

---

# 🏁 최종 요약

> "Student를 상속한 다양한 하위 클래스를 제네릭 저장소에 저장하고,  
> `? extends Student` 와일드카드를 이용해 타입 유연성을 확보하였다. Stream을 이용해 컬렉션 처리 가독성도 향상시켰다."

---
